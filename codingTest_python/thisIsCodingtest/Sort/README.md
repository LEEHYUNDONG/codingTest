# Sort
__정렬__ 이란 `데이터를 특정한 기준에 따라서 순서대로 나열`하는 것을 의미.

### 🃏 선택 정렬
> 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음으로 작은 데이털ㄹ 선택해 앞에서 두 번째 데이터와 바꾸는 과정 반복
 
[코드](selectionSort.py)

#### ⏰ 시간 복잡도
선택 정렬은 n-1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야한다. 또한 매번 가장 작은 수를 찾기 위해서 비교 얀산이 필요하다. 구현방식에 따라서 오차가 있을 수도 있지만 연산 횟수는 n+(n-1)+(n-2)+...2 
즉, n*(n+1) / 2 연산을 수행하기 때문에 시간 복잡도는 O(n^2)가 된다.

### 🃏 삽입 정렬
> 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입한다.
선택 정렬 보다  시간 측면에서 더 효율적인 알고리즘.
 
[코드](insertionSort.py)

#### ⏰ 시간 복잡도
average case는 O(n^2)의 시간 복잡도를 가지지만 만약에 정렬이 어느정도 되어있는 데이터를 돌리면 O(n)의 시간복잡도가 나온다.

### 🃏 퀵 정렬
> 기준 데이터(피봇)로 부터 큰 데이터와 작은 데이터의 위치를 바꿔간다.
- 피벗은 큰 숫자와 작은 숫자를 교환할 때의 기준이 되는 수. 피벗을 어떻게 설정하는 지에 따라서 성능이 달라진다.

[코드1](quickSort.py)
[코드2](quickSort_2.py)

#### ⏰ 시간 복잡도
퀴 정렬의 평균 시간 복잡도는 O(nlog(n))이다. 이미 정렬되어 있는 경우 느리게 동작한다. 

### 🃏 계수 정렬
> 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000 미만일 때 효과적이다. 계수 정렬은 모든 범위를 담을 수 있는 크기의 리스트를 선언해양 하기 때문에 데이터의 차이가 너무 크면 사용할 수 없다.
 또, 비교 기반의 정렬 알고리즘이 아니다.
- 데이터의 크기가 제한되어 있을 때에 한해서 데이터의 개수가 많더라도 빠르게 동작.
- 동일한 데이터가 여러 개 등장할 때 적합

[코드](countSort.py)

#### ⏰ 시간 복잡도
최악의 경우에도 O(n+k)의 시간 복잡도를 가진다.

