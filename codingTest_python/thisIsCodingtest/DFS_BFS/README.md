## 🌼 Dfs/Bfs
> __탐색__이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
너비 우선 탐색과 깊이 우선 탐색에 들어가기 전에 알아야하는 자료구조
- Stack
- Queue
너비 우선 탐색은 큐를 깊이 우선 탐색은 스택 자료구조 형식을 통하여 탐색한다. 특히 깊이 우선 탐색은 최대한 깊은 곳 까지 뻣어내려가야 하기 때문에 stack을 이용하는데, stack자료구조를 활용하기 위해서 재귀적(recursive)하게 동작한다.
개인적으로 생각을 해보았을 때, dfs는 모든 경우를 탐색하고 특히 __경우의수, 특정 모양으로 그래프 탐색__ 등 최적의 해를 보장하지 않는 케이스를 연산할 때 많이 사용했다. 반면에 너비 우선 탐색은 동시에 뻣어져 나가는 형식 즉 큐에 __일수나 특정 item의 개수를__ 같이 저장하여 최적의 해를 보장할 수 있는 방법이 있다.

#### 🍄 Stack
- 선입후출
- top을 통하여 맨 위에 있는 아이템을 확인
- ex) 보통 햄버거 처럼 바닥에 깔려 있는 것 가장 나중에 들어올리고 맨위에 있는 레이어에만 접근 할 수 있다.
- 입력 순서와 출력 순서가 반대
- 일반 적인 파이썬 리스트로 구현 가능

#### 🍄 Queue
- 선입선출
- front가 존재한다. 사실 일반 queue보다 deque를 더 많이 사용
- ex) 네트워크 통신 큐, 마트에서 계산대 먼저 줄 선 사람이 먼저 계산을 하고 나가는 것
= 입력 순서와 출력 순서가 동일

### 🦚 Dfs 깊이 우선 탐색
그래프에서 `깊은 부분을 우선적`으로 탐색하는 알고리즘

> 그래프
- 인접 행렬 => 이차원 배열로 그래프의 연결관계를 표시한다. 데이터의 낭비가 있다. 하지면 접근이 빠름
- 인접 리스트 => 리스트로 그래프의 연결 관계를 표시한다. 데이터의 소모가 없음. 연결된 그래프만 메달기 때문 

```
INF = 99999999

# 인접 행렬
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]
# 인접 리스트
graph = [
    [1, 2],
    [],
    [3]
]
```
[코드](dfs.py)

### 🦚 Bfs 너비 우선 탐색
`가까운 노드` 부터 탑색하는 알고리즘

`dfs보다 bfs가 빠르게 동작한다. queue를 이용하기도 하고 동시에 뻣어져나감과 동시에 deque 자체도 빠른 라이브러리이다.`
[코드](/)

